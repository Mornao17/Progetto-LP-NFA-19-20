;;;; Progetto NFA Cantoni Romano


;;;Funzione is-regexp
(defun is-regexp(RE)
  (cond
   ((atom RE) T)
   ((eql (first RE) 'seq)
    (regexp (rest RE)))
   ((eql (first RE) 'or)
    (regexp (rest RE)))
   ((eql (first RE) 'star) 
    (if (null (rest(rest RE)))
        (regexp (rest RE)) NIL))
   ((eql (first RE) 'plus) 
    (if (null (rest(rest RE))) 
        (regexp (rest RE)) NIL))
   (T(if (listp RE)T))
  )
)

;;appoggio a is-regexp
;;seq/star/or/plus riconosciuto
(defun regexp(RE) 
  (cond
   ((or(atom RE) (listp RE)) T)
   ((eql (first RE) 'seq)
    (regexp (rest RE)))
   ((eql (first RE) 'or)
    (regexp (rest RE)))
   ((eql (first RE) 'star) 
    (if (null (rest(rest RE)))
        (regexp (rest RE)) NIL))
   ((eql (first RE) 'plus) 
    (if (null (rest(rest RE))) 
        (regexp (rest RE)) NIL))
   (T(is-regexp (rest RE)))
  )
)

;;;Funzione nfa-regexp-comp
(defun nfa-regexp-comp (RE)
  (cond
   ;;se è un atomo creo l'automa
   ((atom RE) 
    (list '(initial 0) (list 'delta 0 RE -1) '(final -1)))
   ;;no funotir accettati
   ((and (not(eql(first re) 'star)) 
              (not(eql(first re) 'seq)) 
              (not(eql(first re) 'or)) 
              (not(eql(first re) 'plus)))
         (list '(initial 0) (list 'delta 0 re -1) '(final -1)))
   ;;se è una regexp passo alla funzione per creare l'automa
   ((is-regexp RE)
    (append (list '(initial 0)) (nfa-comp RE nil 0 0)))))

;;ricorsione comp
(defun nfa-comp (RE res ini fin)
  (cond  
   ((and(eql RE  nil)(eql res nil)) 
    (append (list (nfa-epsilon ini -1))
            (list(list 'final -1))))
   ((and(eql re nil) (not(eql res nil))) '())
   ((eql (first RE) 'seq) 
    (nfa-seq (rest RE) res ini fin)) 
   ((eql (first RE) 'or) 
    (nfa-or (rest RE) res ini fin))
   ((eql (first RE) 'star) 
    (nfa-star (rest RE) res ini fin))
   ((eql (first RE) 'plus) 
    (nfa-plus (rest RE) res ini fin))))







;;atomo
(defun nfa-atom (RE s)
  (list  'delta s re (+ s 1)))

;;epsilon  mossa
(defun nfa-epsilon (ini fin)
  (list 'delta ini 'epsilon fin))



;;creazione seq
(defun nfa-seq (RE res ini fin)
  (cond ((and (eql RE nil) (eql res nil)) 
         (append (list (nfa-epsilon ini (+ fin 1)))
                 (nfa-comp RE res (+ fin 1) (+ fin 1))))
        ((and (eql RE nil) (not(eql res nil))) 
         (list (nfa-epsilon ini (+ fin 1))))
        ((atom (first RE)) 
         (append  (list (nfa-epsilon ini (+ fin 1))) 
                  (list(nfa-atom  (first RE) (+ fin 1)))  
                  (nfa-seq (rest re) res (+ fin 2) (+ fin 2))))
        ((and(not(eql(first(first re)) 'star)) 
             (not(eql(first(first re)) 'seq)) 
             (not(eql(first(first re)) 'or)) 
             (not(eql(first (first re)) 'plus)))
         (append  (list(list ini 'epsilon (+ fin 1))) 
                  (list(nfa-atom  (first RE) (+ fin 1)))  
                  (nfa-seq (rest RE) res (+ fin 2) (+ fin 2))))
        (T (append (nfa-comp  (first RE) 
                                        (append '(c) (rest RE)) fin fin) 
                   (nfa-seq (rest RE) res 
                               (cond ((eql (first(first RE)) 'seq)
                                      (+ ini (conta-stati(first RE))))
                                     (T (+ ini 3))) 
                               (+ fin (conta-stati (first RE))))))))

;;creazione or
(defun nfa-or (RE res ini fin)
  (cond ((and(eql RE nil) (eql res nil)) (nfa-comp RE res (+ ini 3) fin))
        ((and(eql RE nil) (not(eql res nil))) '())
        ((atom (first RE)) 
         (append(list (nfa-epsilon ini (+ fin 1)) 
                      (nfa-epsilon (+ fin 2) (+ ini 3)) 
                      (nfa-atom (first RE) (+ fin 1))) 
                (nfa-or (rest RE) res ini (cond ((equal fin ini) (+ fin 3))
                                                 (T (+ fin 2))))))
        ((and(not(eql(first(first RE)) 'star)) 
             (not(eql(first(first RE)) 'seq)) 
             (not(eql(first(first RE)) 'or)) 
             (not(eql(first (first RE)) 'plus)))
         (append(list (nfa-epsilon ini (+ fin 1)) 
                      (nfa-epsilon (+ fin 2) (+ ini 3)) 
                      (nfa-atom (first RE) (+ fin 1))) 
                (nfa-or (rest RE) res ini (+ fin 3))))
        (T(append (list(list 'delta (cond((eql (first(first RE)) 'seq)
                                          (+ fin (conta-stati(first RE))))
                                         (T (+ fin 3))) 'epsilon (+ ini 3)))
                  (nfa-comp (first RE) 
                                      (append '(c) (rest RE)) 
                                       ini  
                                       fin )
                  (nfa-or (rest RE) res ini 
                             (+ fin (conta-stati (first RE))))))))


;;creazione star
(defun nfa-star (RE res ini fin)
  (cond ((and(eql RE nil) (eql res nil)) 
         (nfa-comp RE res ini fin))
        ((and(eql RE nil) (not(eql res nil))) '())
        ((atom (first RE)) 
         (append (list (nfa-epsilon ini (+ fin 1))) 
                 (list (nfa-epsilon (+ fin 2) (+ ini 3))) 
                 (list (nfa-epsilon ini (+ ini 3)))
                 (list (nfa-epsilon (+ fin 2) (+ fin 1))) 
                 (list (nfa-atom (first RE) (+ fin 1)))
                 (nfa-star (rest RE) res (+ ini 3) (+ ini 3))))
        ((and(not(eql(first(first RE)) 'star)) 
             (not(eql(first(first RE)) 'seq)) 
             (not(eql(first(first RE)) 'or)) 
             (not(eql(first (first RE)) 'plus)))
         (append (list (nfa-epsilon ini (+ fin 1))) 
                 (list (nfa-epsilon (+ fin 2) (+ ini 3))) 
                 (list (nfa-epsilon ini (+ ini 3))) 
                 (list (nfa-epsilon (+ fin 2) (+ fin 1))) 
                 (list (nfa-atom (first RE) (+ fin 1)))
                 (nfa-star (rest RE) res ( + ini 3) (+ ini 3))))
        (T(append (list (nfa-epsilon ini (+ fin 1))) 
                  (list (nfa-epsilon ini (+ (+ fin 1) (conta-stati (first RE )) 1))) 
                  (list(list 'delta (cond((eql (first(first RE)) 'seq)
                                          (+ (+ fin 1) (conta-stati(first RE))))
                                         (T (+ fin 4))) 'epsilon (+ (+ fin 1) (conta-stati (first RE )) 1)))
                  (list(list 'delta (cond((eql (first(first RE)) 'seq)
                                          (+ (+ fin 1) (conta-stati(first RE))))
                                         (T (+ fin 4))) 'epsilon (+ fin 1)))
                  (nfa-comp (first RE) (append '(c) (rest RE)) (+ fin 1) (+ fin 1))
                  (nfa-star (rest RE) res (+ (+ fin 1) (conta-stati (first RE)) 1) (+ fin (conta-stati (first RE))))))))


;;creazione plus
(defun nfa-plus (RE res ini fin)
  (cond ((and(eql RE nil) (eql res nil)) 
         (nfa-comp RE res ini fin))
        ((and(eql RE nil) (not(eql res nil))) '())
        ((atom (first RE)) 
         (append (list (nfa-epsilon ini (+ fin 1))) 
                 (list (nfa-epsilon (+ fin 2) (+ ini 3)))  
                 (list (nfa-epsilon (+ fin 2) (+ fin 1))) 
                 (list(nfa-atom (first RE) (+ fin 1)))
                 (nfa-plus (rest RE) res (+ ini 3) (+ ini 3))))
        ((and(not(eql(first(first RE)) 'star)) 
             (not(eql(first(first RE)) 'seq)) 
             (not(eql(first(first RE)) 'or)) 
             (not(eql(first (first RE)) 'plus)))
         (append (list (nfa-epsilon ini (+ fin 1))) 
                 (list (nfa-epsilon (+ fin 2) (+ ini 3)))  
                 (list (nfa-epsilon (+ fin 2) (+ fin 1))) 
                 (list(nfa-atom (first RE) (+ fin 1)))
                 (nfa-plus (rest RE) res (+ ini 3) (+ ini 3))))
        (T(append (list (nfa-epsilon ini (+ fin 1))) 
                  (list(list 'delta (cond((eql (first(first RE)) 'seq)
                                          (+ (+ fin 1) (conta-stati(first RE))))
                                         (T (+ fin 4))) 'epsilon (+ (+ fin 1) (conta-stati (first RE)) 1)))
                  (list(list 'delta (cond((eql (first(first RE)) 'seq)
                                          (+ (+ fin 1) (conta-stati(first RE))))
                                         (T (+ fin 4))) 'epsilon (+ fin 1)))
                  (nfa-comp (first RE) (append '(c) (rest RE)) (+ fin 1) (+ fin 1))
                  (nfa-plus (rest RE) res ini (+ (+ fin (conta-stati (first RE)) 1) (+ fin (conta-stati (first RE)))))))))

         


;;conteggio stati 
(defun conta-stati (RE)
  (cond ((eql RE nil) 0)
        ((and (atom RE) (not(eql RE 'seq)) (not (eql RE 'or)) (not (eql RE 'star)) (not (eql RE 'plus ))) 2)
        ((and(eql (first RE) 'seq)(eql(rest RE) nil))1)
        ((and(eql (first RE) 'or)(eql(rest RE) nil))1)
        ((and(atom (first RE))(eql (rest RE) nil)) 2)
        ((eql (first RE) 'seq)  (+ (conta-stati (first (rest RE))) (conta-stati (append '(seq)(rest (rest RE))))))
        ((eql (first RE) 'or)  (+ (conta-stati (first (rest RE))) (conta-stati (append '(or) (rest (rest RE))))))
        ((and (eql (first RE) 'star) (atom (second RE))) 3)
        ((eql (first RE) 'star) (+ (conta-stati (first (rest RE))) 2))
        ((and (eql (first RE) 'plus) (atom (second RE))) 3)
        ((eql (first RE) 'plus) (+ (conta-stati (first (rest RE))) 2))))

(defun nfa-test (fa in)
  (cond ((not (is-automa fa nil)) (error "~S is not a Finite State Automata." fa))
        (T (nfa-subtest fa fa in (list-test fa fa 'initial nil nil)))))

(defun list-test (fa fas in ins n)
  (cond ((and (eql fas nil) (eql (first ins ) 'epsilon)) T)
        ((eql fas nil) nil)
        ((eql in 'initial) (cond ((eql (first(first fas)) 'initial) (second(first fas)))
                                 (T(list-test fa (rest fas) 'final ins n))))
        ((eql in 'final) (cond ((eql (first(first fas)) 'final) (eql (second(first fas)) n))
                               (T(list-test fa (rest fas) 'final ins n))))

        ((eql in 'epsilon)
         (cond ((and (eql (second(first fas)) n)(eql (third(first fas)) 'epsilon)) (or(nfa-subtest fa fa ins (fourth(first fas))) (nfa-subtest fa (rest fas)ins n)))
               (T(list-test fa (rest fas) in ins n))))
        (T(cond ((and (eql (second (first fas)) n)(equal (third(first fas)) in)) (nfa-subtest fa fa ins (fourth(first fas))))
                (T(list-test fa (rest fas) in ins n))))))

(defun is-automa ( fa n)
  (cond ((and(eql fa nil) (eql n nil)) nil)
         ((and (eql fa nil) (eql n 1))T)
         ((atom fa) nil)
         ((atom (first fa)) nil)
         ((eql (first (first fa)) 'initial) (is-automa (rest fa) 1))
         ((eql (first (first fa)) 'delta) (is-automa (rest fa) 1))
         ((eql (first(first fa)) 'final) (is-automa (rest fa) 1))))

(defun nfa-subtest (fa fas in n)
  (cond ((and (eql in nil)(list-test fa fa 'epsilon '(epsilon) n) (list-test fa fa 'final nil n))T)
        (T(or(list-test fa fas (first in) (rest in)n) (list-test fa fas 'epsilon in n)))))

                            
        
