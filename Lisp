;;;; Progetto NFA Cantoni Romano

;;;Funzione is-regexp
(defun is-regexp(RE)
  (cond
   ((atom RE) T)
   ((eql (first RE) 'seq)
    (regexp (rest RE)))
   ((eql (first RE) 'or)
    (regexp (rest RE)))
   ((eql (first RE) 'star) 
    (if (null (rest(rest RE)))
        (regexp (rest RE)) NIL))
   ((eql (first RE) 'plus) 
    (if (null (rest(rest RE))) 
        (regexp (rest RE)) NIL))
   (T(if (listp RE)T))
  )
)

;;appoggio a is-regexp
;;seq/star/or/plus riconosciuto
(defun regexp(RE) 
  (cond
   ((or(atom RE) (listp RE)) T)
   ((eql (first RE) 'seq)
    (regexp (rest RE)))
   ((eql (first RE) 'or)
    (regexp (rest RE)))
   ((eql (first RE) 'star) 
    (if (null (rest(rest RE)))
        (regexp (rest RE)) NIL))
   ((eql (first RE) 'plus) 
    (if (null (rest(rest RE))) 
        (regexp (rest RE)) NIL))
   (T(is-regexp (rest RE)))
  )
)

;;;Funzione nfa-regexp-comp

(defun nfa-regexp-comp (RE)
  ;(is-regexp (RE))
  (cond
   ((eql (first RE) 'seq)
    (nfa-seq (rest RE) 0))
   ((eql (first RE) 'or)
   (nfa-or(rest re) 0))
   ((eql (first RE) 'star)
    (nfa-star(rest RE) 0))
   ((eql (first RE) 'plus)
    (nfa-plus(rest RE) 0))
   )
)

;;ricorsione comp
(defun nfa-comp (RE i)
  ;(is-regexp (RE))
  (cond
   ((eql (first RE) 'seq)
    (list '(start 0))
    (nfa-seq (rest RE) (+ i 1)))
   ((eql (first RE) 'or)
   (nfa-or(rest re) (+ i 1)))
   ((eql (first RE) 'star)
   (nfa-star(rest re) (+ i 1)))
   ((eql (first RE) 'plus)
   (nfa-plus(rest re) (+ i 1)))
   )
)
;;atomo
(defun nfa-atom (ini re fin)
  (list  ini re  fin))

;;epsilon  mossa
(defun nfa-epsilon (ini fin)
  (list ini 'epsilon fin))

;;stato finale
(defun nfa-final (ini )
  (list ini 'epsilon -1))

;;creazione seq
(defun nfa-seq (RE a)
  (cond (( eql re nil) 
         (list(nfa-final a)))
        ((or  ;ritorno alla funzione comp se trovo un funtore accettato
          (eql (first(first re)) 'or) 
          (eql (first re) 'seq) 
          (eql (first re) 'star) 
          (eql(first re) 'plus))
         (nfa-comp RE a))
        ((atom (first RE))
         (append (list (nfa-epsilon a (+ a 1)))
                 (list(list (+ a 1) (first RE) (+ a 2)))
                       (nfa-seq  (rest RE) (+ a 2))))))

;;creazione or
(defun nfa-or (re a)
  (append (list (nfa-epsilon a (+ a 1)))
          (list (nfa-atom (+ a 1) (first re) (+ a 2)))
          (list(nfa-epsilon (+ a 2) -1))
          (if (not (eql (rest re) nil))
              (nfa-or (rest re) (+ a 2)))))

;;creazione star
(defun nfa-star(RE a)
  (append (list (nfa-epsilon a (+ a 1)))
          (list (nfa-epsilon a -1))
          (list (nfa-epsilon -1 a))
          (list( nfa-atom (+ a 1) (first re) (+ a 2)))
          (list( nfa-atom (+ a 2) (first re) (+ a 1)))
          (list (nfa-epsilon (+ a 1) (+ a 2)))
          (list(nfa-epsilon (+ a 2) -1)))
)

;;creazione plus
(defun nfa-plus(RE a)
  (append (list (nfa-epsilon a (+ a 1)))
          (list (nfa-epsilon -1 a))
          (list( nfa-atom (+ a 1) (first re) (+ a 2)))
          (list( nfa-atom (+ a 2) (first re) (+ a 1)))
          (list(nfa-epsilon (+ a 2) -1)))
)

